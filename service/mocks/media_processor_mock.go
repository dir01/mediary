// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_service "github.com/dir01/mediary/service"
	"github.com/gojuno/minimock/v3"
)

// MediaProcessorMock implements mm_service.MediaProcessor
type MediaProcessorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddChapterTags          func(ctx context.Context, filepath string, chapters []mm_service.Chapter) (err error)
	funcAddChapterTagsOrigin    string
	inspectFuncAddChapterTags   func(ctx context.Context, filepath string, chapters []mm_service.Chapter)
	afterAddChapterTagsCounter  uint64
	beforeAddChapterTagsCounter uint64
	AddChapterTagsMock          mMediaProcessorMockAddChapterTags

	funcConcatenate          func(ctx context.Context, filepaths []string, audioCodec string) (resultFilepath string, err error)
	funcConcatenateOrigin    string
	inspectFuncConcatenate   func(ctx context.Context, filepaths []string, audioCodec string)
	afterConcatenateCounter  uint64
	beforeConcatenateCounter uint64
	ConcatenateMock          mMediaProcessorMockConcatenate

	funcGetInfo          func(ctx context.Context, filepath string) (info *mm_service.MediaInfo, err error)
	funcGetInfoOrigin    string
	inspectFuncGetInfo   func(ctx context.Context, filepath string)
	afterGetInfoCounter  uint64
	beforeGetInfoCounter uint64
	GetInfoMock          mMediaProcessorMockGetInfo
}

// NewMediaProcessorMock returns a mock for mm_service.MediaProcessor
func NewMediaProcessorMock(t minimock.Tester) *MediaProcessorMock {
	m := &MediaProcessorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddChapterTagsMock = mMediaProcessorMockAddChapterTags{mock: m}
	m.AddChapterTagsMock.callArgs = []*MediaProcessorMockAddChapterTagsParams{}

	m.ConcatenateMock = mMediaProcessorMockConcatenate{mock: m}
	m.ConcatenateMock.callArgs = []*MediaProcessorMockConcatenateParams{}

	m.GetInfoMock = mMediaProcessorMockGetInfo{mock: m}
	m.GetInfoMock.callArgs = []*MediaProcessorMockGetInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMediaProcessorMockAddChapterTags struct {
	optional           bool
	mock               *MediaProcessorMock
	defaultExpectation *MediaProcessorMockAddChapterTagsExpectation
	expectations       []*MediaProcessorMockAddChapterTagsExpectation

	callArgs []*MediaProcessorMockAddChapterTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MediaProcessorMockAddChapterTagsExpectation specifies expectation struct of the MediaProcessor.AddChapterTags
type MediaProcessorMockAddChapterTagsExpectation struct {
	mock               *MediaProcessorMock
	params             *MediaProcessorMockAddChapterTagsParams
	paramPtrs          *MediaProcessorMockAddChapterTagsParamPtrs
	expectationOrigins MediaProcessorMockAddChapterTagsExpectationOrigins
	results            *MediaProcessorMockAddChapterTagsResults
	returnOrigin       string
	Counter            uint64
}

// MediaProcessorMockAddChapterTagsParams contains parameters of the MediaProcessor.AddChapterTags
type MediaProcessorMockAddChapterTagsParams struct {
	ctx      context.Context
	filepath string
	chapters []mm_service.Chapter
}

// MediaProcessorMockAddChapterTagsParamPtrs contains pointers to parameters of the MediaProcessor.AddChapterTags
type MediaProcessorMockAddChapterTagsParamPtrs struct {
	ctx      *context.Context
	filepath *string
	chapters *[]mm_service.Chapter
}

// MediaProcessorMockAddChapterTagsResults contains results of the MediaProcessor.AddChapterTags
type MediaProcessorMockAddChapterTagsResults struct {
	err error
}

// MediaProcessorMockAddChapterTagsOrigins contains origins of expectations of the MediaProcessor.AddChapterTags
type MediaProcessorMockAddChapterTagsExpectationOrigins struct {
	origin         string
	originCtx      string
	originFilepath string
	originChapters string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Optional() *mMediaProcessorMockAddChapterTags {
	mmAddChapterTags.optional = true
	return mmAddChapterTags
}

// Expect sets up expected params for MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Expect(ctx context.Context, filepath string, chapters []mm_service.Chapter) *mMediaProcessorMockAddChapterTags {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	if mmAddChapterTags.defaultExpectation == nil {
		mmAddChapterTags.defaultExpectation = &MediaProcessorMockAddChapterTagsExpectation{}
	}

	if mmAddChapterTags.defaultExpectation.paramPtrs != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by ExpectParams functions")
	}

	mmAddChapterTags.defaultExpectation.params = &MediaProcessorMockAddChapterTagsParams{ctx, filepath, chapters}
	mmAddChapterTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddChapterTags.expectations {
		if minimock.Equal(e.params, mmAddChapterTags.defaultExpectation.params) {
			mmAddChapterTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddChapterTags.defaultExpectation.params)
		}
	}

	return mmAddChapterTags
}

// ExpectCtxParam1 sets up expected param ctx for MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) ExpectCtxParam1(ctx context.Context) *mMediaProcessorMockAddChapterTags {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	if mmAddChapterTags.defaultExpectation == nil {
		mmAddChapterTags.defaultExpectation = &MediaProcessorMockAddChapterTagsExpectation{}
	}

	if mmAddChapterTags.defaultExpectation.params != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Expect")
	}

	if mmAddChapterTags.defaultExpectation.paramPtrs == nil {
		mmAddChapterTags.defaultExpectation.paramPtrs = &MediaProcessorMockAddChapterTagsParamPtrs{}
	}
	mmAddChapterTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddChapterTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddChapterTags
}

// ExpectFilepathParam2 sets up expected param filepath for MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) ExpectFilepathParam2(filepath string) *mMediaProcessorMockAddChapterTags {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	if mmAddChapterTags.defaultExpectation == nil {
		mmAddChapterTags.defaultExpectation = &MediaProcessorMockAddChapterTagsExpectation{}
	}

	if mmAddChapterTags.defaultExpectation.params != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Expect")
	}

	if mmAddChapterTags.defaultExpectation.paramPtrs == nil {
		mmAddChapterTags.defaultExpectation.paramPtrs = &MediaProcessorMockAddChapterTagsParamPtrs{}
	}
	mmAddChapterTags.defaultExpectation.paramPtrs.filepath = &filepath
	mmAddChapterTags.defaultExpectation.expectationOrigins.originFilepath = minimock.CallerInfo(1)

	return mmAddChapterTags
}

// ExpectChaptersParam3 sets up expected param chapters for MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) ExpectChaptersParam3(chapters []mm_service.Chapter) *mMediaProcessorMockAddChapterTags {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	if mmAddChapterTags.defaultExpectation == nil {
		mmAddChapterTags.defaultExpectation = &MediaProcessorMockAddChapterTagsExpectation{}
	}

	if mmAddChapterTags.defaultExpectation.params != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Expect")
	}

	if mmAddChapterTags.defaultExpectation.paramPtrs == nil {
		mmAddChapterTags.defaultExpectation.paramPtrs = &MediaProcessorMockAddChapterTagsParamPtrs{}
	}
	mmAddChapterTags.defaultExpectation.paramPtrs.chapters = &chapters
	mmAddChapterTags.defaultExpectation.expectationOrigins.originChapters = minimock.CallerInfo(1)

	return mmAddChapterTags
}

// Inspect accepts an inspector function that has same arguments as the MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Inspect(f func(ctx context.Context, filepath string, chapters []mm_service.Chapter)) *mMediaProcessorMockAddChapterTags {
	if mmAddChapterTags.mock.inspectFuncAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("Inspect function is already set for MediaProcessorMock.AddChapterTags")
	}

	mmAddChapterTags.mock.inspectFuncAddChapterTags = f

	return mmAddChapterTags
}

// Return sets up results that will be returned by MediaProcessor.AddChapterTags
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Return(err error) *MediaProcessorMock {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	if mmAddChapterTags.defaultExpectation == nil {
		mmAddChapterTags.defaultExpectation = &MediaProcessorMockAddChapterTagsExpectation{mock: mmAddChapterTags.mock}
	}
	mmAddChapterTags.defaultExpectation.results = &MediaProcessorMockAddChapterTagsResults{err}
	mmAddChapterTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddChapterTags.mock
}

// Set uses given function f to mock the MediaProcessor.AddChapterTags method
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Set(f func(ctx context.Context, filepath string, chapters []mm_service.Chapter) (err error)) *MediaProcessorMock {
	if mmAddChapterTags.defaultExpectation != nil {
		mmAddChapterTags.mock.t.Fatalf("Default expectation is already set for the MediaProcessor.AddChapterTags method")
	}

	if len(mmAddChapterTags.expectations) > 0 {
		mmAddChapterTags.mock.t.Fatalf("Some expectations are already set for the MediaProcessor.AddChapterTags method")
	}

	mmAddChapterTags.mock.funcAddChapterTags = f
	mmAddChapterTags.mock.funcAddChapterTagsOrigin = minimock.CallerInfo(1)
	return mmAddChapterTags.mock
}

// When sets expectation for the MediaProcessor.AddChapterTags which will trigger the result defined by the following
// Then helper
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) When(ctx context.Context, filepath string, chapters []mm_service.Chapter) *MediaProcessorMockAddChapterTagsExpectation {
	if mmAddChapterTags.mock.funcAddChapterTags != nil {
		mmAddChapterTags.mock.t.Fatalf("MediaProcessorMock.AddChapterTags mock is already set by Set")
	}

	expectation := &MediaProcessorMockAddChapterTagsExpectation{
		mock:               mmAddChapterTags.mock,
		params:             &MediaProcessorMockAddChapterTagsParams{ctx, filepath, chapters},
		expectationOrigins: MediaProcessorMockAddChapterTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddChapterTags.expectations = append(mmAddChapterTags.expectations, expectation)
	return expectation
}

// Then sets up MediaProcessor.AddChapterTags return parameters for the expectation previously defined by the When method
func (e *MediaProcessorMockAddChapterTagsExpectation) Then(err error) *MediaProcessorMock {
	e.results = &MediaProcessorMockAddChapterTagsResults{err}
	return e.mock
}

// Times sets number of times MediaProcessor.AddChapterTags should be invoked
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Times(n uint64) *mMediaProcessorMockAddChapterTags {
	if n == 0 {
		mmAddChapterTags.mock.t.Fatalf("Times of MediaProcessorMock.AddChapterTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddChapterTags.expectedInvocations, n)
	mmAddChapterTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddChapterTags
}

func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) invocationsDone() bool {
	if len(mmAddChapterTags.expectations) == 0 && mmAddChapterTags.defaultExpectation == nil && mmAddChapterTags.mock.funcAddChapterTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddChapterTags.mock.afterAddChapterTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddChapterTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddChapterTags implements mm_service.MediaProcessor
func (mmAddChapterTags *MediaProcessorMock) AddChapterTags(ctx context.Context, filepath string, chapters []mm_service.Chapter) (err error) {
	mm_atomic.AddUint64(&mmAddChapterTags.beforeAddChapterTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddChapterTags.afterAddChapterTagsCounter, 1)

	mmAddChapterTags.t.Helper()

	if mmAddChapterTags.inspectFuncAddChapterTags != nil {
		mmAddChapterTags.inspectFuncAddChapterTags(ctx, filepath, chapters)
	}

	mm_params := MediaProcessorMockAddChapterTagsParams{ctx, filepath, chapters}

	// Record call args
	mmAddChapterTags.AddChapterTagsMock.mutex.Lock()
	mmAddChapterTags.AddChapterTagsMock.callArgs = append(mmAddChapterTags.AddChapterTagsMock.callArgs, &mm_params)
	mmAddChapterTags.AddChapterTagsMock.mutex.Unlock()

	for _, e := range mmAddChapterTags.AddChapterTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddChapterTags.AddChapterTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddChapterTags.AddChapterTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddChapterTags.AddChapterTagsMock.defaultExpectation.params
		mm_want_ptrs := mmAddChapterTags.AddChapterTagsMock.defaultExpectation.paramPtrs

		mm_got := MediaProcessorMockAddChapterTagsParams{ctx, filepath, chapters}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddChapterTags.t.Errorf("MediaProcessorMock.AddChapterTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddChapterTags.AddChapterTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filepath != nil && !minimock.Equal(*mm_want_ptrs.filepath, mm_got.filepath) {
				mmAddChapterTags.t.Errorf("MediaProcessorMock.AddChapterTags got unexpected parameter filepath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddChapterTags.AddChapterTagsMock.defaultExpectation.expectationOrigins.originFilepath, *mm_want_ptrs.filepath, mm_got.filepath, minimock.Diff(*mm_want_ptrs.filepath, mm_got.filepath))
			}

			if mm_want_ptrs.chapters != nil && !minimock.Equal(*mm_want_ptrs.chapters, mm_got.chapters) {
				mmAddChapterTags.t.Errorf("MediaProcessorMock.AddChapterTags got unexpected parameter chapters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddChapterTags.AddChapterTagsMock.defaultExpectation.expectationOrigins.originChapters, *mm_want_ptrs.chapters, mm_got.chapters, minimock.Diff(*mm_want_ptrs.chapters, mm_got.chapters))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddChapterTags.t.Errorf("MediaProcessorMock.AddChapterTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddChapterTags.AddChapterTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddChapterTags.AddChapterTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddChapterTags.t.Fatal("No results are set for the MediaProcessorMock.AddChapterTags")
		}
		return (*mm_results).err
	}
	if mmAddChapterTags.funcAddChapterTags != nil {
		return mmAddChapterTags.funcAddChapterTags(ctx, filepath, chapters)
	}
	mmAddChapterTags.t.Fatalf("Unexpected call to MediaProcessorMock.AddChapterTags. %v %v %v", ctx, filepath, chapters)
	return
}

// AddChapterTagsAfterCounter returns a count of finished MediaProcessorMock.AddChapterTags invocations
func (mmAddChapterTags *MediaProcessorMock) AddChapterTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddChapterTags.afterAddChapterTagsCounter)
}

// AddChapterTagsBeforeCounter returns a count of MediaProcessorMock.AddChapterTags invocations
func (mmAddChapterTags *MediaProcessorMock) AddChapterTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddChapterTags.beforeAddChapterTagsCounter)
}

// Calls returns a list of arguments used in each call to MediaProcessorMock.AddChapterTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddChapterTags *mMediaProcessorMockAddChapterTags) Calls() []*MediaProcessorMockAddChapterTagsParams {
	mmAddChapterTags.mutex.RLock()

	argCopy := make([]*MediaProcessorMockAddChapterTagsParams, len(mmAddChapterTags.callArgs))
	copy(argCopy, mmAddChapterTags.callArgs)

	mmAddChapterTags.mutex.RUnlock()

	return argCopy
}

// MinimockAddChapterTagsDone returns true if the count of the AddChapterTags invocations corresponds
// the number of defined expectations
func (m *MediaProcessorMock) MinimockAddChapterTagsDone() bool {
	if m.AddChapterTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddChapterTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddChapterTagsMock.invocationsDone()
}

// MinimockAddChapterTagsInspect logs each unmet expectation
func (m *MediaProcessorMock) MinimockAddChapterTagsInspect() {
	for _, e := range m.AddChapterTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MediaProcessorMock.AddChapterTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddChapterTagsCounter := mm_atomic.LoadUint64(&m.afterAddChapterTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddChapterTagsMock.defaultExpectation != nil && afterAddChapterTagsCounter < 1 {
		if m.AddChapterTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MediaProcessorMock.AddChapterTags at\n%s", m.AddChapterTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MediaProcessorMock.AddChapterTags at\n%s with params: %#v", m.AddChapterTagsMock.defaultExpectation.expectationOrigins.origin, *m.AddChapterTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddChapterTags != nil && afterAddChapterTagsCounter < 1 {
		m.t.Errorf("Expected call to MediaProcessorMock.AddChapterTags at\n%s", m.funcAddChapterTagsOrigin)
	}

	if !m.AddChapterTagsMock.invocationsDone() && afterAddChapterTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to MediaProcessorMock.AddChapterTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddChapterTagsMock.expectedInvocations), m.AddChapterTagsMock.expectedInvocationsOrigin, afterAddChapterTagsCounter)
	}
}

type mMediaProcessorMockConcatenate struct {
	optional           bool
	mock               *MediaProcessorMock
	defaultExpectation *MediaProcessorMockConcatenateExpectation
	expectations       []*MediaProcessorMockConcatenateExpectation

	callArgs []*MediaProcessorMockConcatenateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MediaProcessorMockConcatenateExpectation specifies expectation struct of the MediaProcessor.Concatenate
type MediaProcessorMockConcatenateExpectation struct {
	mock               *MediaProcessorMock
	params             *MediaProcessorMockConcatenateParams
	paramPtrs          *MediaProcessorMockConcatenateParamPtrs
	expectationOrigins MediaProcessorMockConcatenateExpectationOrigins
	results            *MediaProcessorMockConcatenateResults
	returnOrigin       string
	Counter            uint64
}

// MediaProcessorMockConcatenateParams contains parameters of the MediaProcessor.Concatenate
type MediaProcessorMockConcatenateParams struct {
	ctx        context.Context
	filepaths  []string
	audioCodec string
}

// MediaProcessorMockConcatenateParamPtrs contains pointers to parameters of the MediaProcessor.Concatenate
type MediaProcessorMockConcatenateParamPtrs struct {
	ctx        *context.Context
	filepaths  *[]string
	audioCodec *string
}

// MediaProcessorMockConcatenateResults contains results of the MediaProcessor.Concatenate
type MediaProcessorMockConcatenateResults struct {
	resultFilepath string
	err            error
}

// MediaProcessorMockConcatenateOrigins contains origins of expectations of the MediaProcessor.Concatenate
type MediaProcessorMockConcatenateExpectationOrigins struct {
	origin           string
	originCtx        string
	originFilepaths  string
	originAudioCodec string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConcatenate *mMediaProcessorMockConcatenate) Optional() *mMediaProcessorMockConcatenate {
	mmConcatenate.optional = true
	return mmConcatenate
}

// Expect sets up expected params for MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) Expect(ctx context.Context, filepaths []string, audioCodec string) *mMediaProcessorMockConcatenate {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	if mmConcatenate.defaultExpectation == nil {
		mmConcatenate.defaultExpectation = &MediaProcessorMockConcatenateExpectation{}
	}

	if mmConcatenate.defaultExpectation.paramPtrs != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by ExpectParams functions")
	}

	mmConcatenate.defaultExpectation.params = &MediaProcessorMockConcatenateParams{ctx, filepaths, audioCodec}
	mmConcatenate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConcatenate.expectations {
		if minimock.Equal(e.params, mmConcatenate.defaultExpectation.params) {
			mmConcatenate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConcatenate.defaultExpectation.params)
		}
	}

	return mmConcatenate
}

// ExpectCtxParam1 sets up expected param ctx for MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) ExpectCtxParam1(ctx context.Context) *mMediaProcessorMockConcatenate {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	if mmConcatenate.defaultExpectation == nil {
		mmConcatenate.defaultExpectation = &MediaProcessorMockConcatenateExpectation{}
	}

	if mmConcatenate.defaultExpectation.params != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Expect")
	}

	if mmConcatenate.defaultExpectation.paramPtrs == nil {
		mmConcatenate.defaultExpectation.paramPtrs = &MediaProcessorMockConcatenateParamPtrs{}
	}
	mmConcatenate.defaultExpectation.paramPtrs.ctx = &ctx
	mmConcatenate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConcatenate
}

// ExpectFilepathsParam2 sets up expected param filepaths for MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) ExpectFilepathsParam2(filepaths []string) *mMediaProcessorMockConcatenate {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	if mmConcatenate.defaultExpectation == nil {
		mmConcatenate.defaultExpectation = &MediaProcessorMockConcatenateExpectation{}
	}

	if mmConcatenate.defaultExpectation.params != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Expect")
	}

	if mmConcatenate.defaultExpectation.paramPtrs == nil {
		mmConcatenate.defaultExpectation.paramPtrs = &MediaProcessorMockConcatenateParamPtrs{}
	}
	mmConcatenate.defaultExpectation.paramPtrs.filepaths = &filepaths
	mmConcatenate.defaultExpectation.expectationOrigins.originFilepaths = minimock.CallerInfo(1)

	return mmConcatenate
}

// ExpectAudioCodecParam3 sets up expected param audioCodec for MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) ExpectAudioCodecParam3(audioCodec string) *mMediaProcessorMockConcatenate {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	if mmConcatenate.defaultExpectation == nil {
		mmConcatenate.defaultExpectation = &MediaProcessorMockConcatenateExpectation{}
	}

	if mmConcatenate.defaultExpectation.params != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Expect")
	}

	if mmConcatenate.defaultExpectation.paramPtrs == nil {
		mmConcatenate.defaultExpectation.paramPtrs = &MediaProcessorMockConcatenateParamPtrs{}
	}
	mmConcatenate.defaultExpectation.paramPtrs.audioCodec = &audioCodec
	mmConcatenate.defaultExpectation.expectationOrigins.originAudioCodec = minimock.CallerInfo(1)

	return mmConcatenate
}

// Inspect accepts an inspector function that has same arguments as the MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) Inspect(f func(ctx context.Context, filepaths []string, audioCodec string)) *mMediaProcessorMockConcatenate {
	if mmConcatenate.mock.inspectFuncConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("Inspect function is already set for MediaProcessorMock.Concatenate")
	}

	mmConcatenate.mock.inspectFuncConcatenate = f

	return mmConcatenate
}

// Return sets up results that will be returned by MediaProcessor.Concatenate
func (mmConcatenate *mMediaProcessorMockConcatenate) Return(resultFilepath string, err error) *MediaProcessorMock {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	if mmConcatenate.defaultExpectation == nil {
		mmConcatenate.defaultExpectation = &MediaProcessorMockConcatenateExpectation{mock: mmConcatenate.mock}
	}
	mmConcatenate.defaultExpectation.results = &MediaProcessorMockConcatenateResults{resultFilepath, err}
	mmConcatenate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConcatenate.mock
}

// Set uses given function f to mock the MediaProcessor.Concatenate method
func (mmConcatenate *mMediaProcessorMockConcatenate) Set(f func(ctx context.Context, filepaths []string, audioCodec string) (resultFilepath string, err error)) *MediaProcessorMock {
	if mmConcatenate.defaultExpectation != nil {
		mmConcatenate.mock.t.Fatalf("Default expectation is already set for the MediaProcessor.Concatenate method")
	}

	if len(mmConcatenate.expectations) > 0 {
		mmConcatenate.mock.t.Fatalf("Some expectations are already set for the MediaProcessor.Concatenate method")
	}

	mmConcatenate.mock.funcConcatenate = f
	mmConcatenate.mock.funcConcatenateOrigin = minimock.CallerInfo(1)
	return mmConcatenate.mock
}

// When sets expectation for the MediaProcessor.Concatenate which will trigger the result defined by the following
// Then helper
func (mmConcatenate *mMediaProcessorMockConcatenate) When(ctx context.Context, filepaths []string, audioCodec string) *MediaProcessorMockConcatenateExpectation {
	if mmConcatenate.mock.funcConcatenate != nil {
		mmConcatenate.mock.t.Fatalf("MediaProcessorMock.Concatenate mock is already set by Set")
	}

	expectation := &MediaProcessorMockConcatenateExpectation{
		mock:               mmConcatenate.mock,
		params:             &MediaProcessorMockConcatenateParams{ctx, filepaths, audioCodec},
		expectationOrigins: MediaProcessorMockConcatenateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConcatenate.expectations = append(mmConcatenate.expectations, expectation)
	return expectation
}

// Then sets up MediaProcessor.Concatenate return parameters for the expectation previously defined by the When method
func (e *MediaProcessorMockConcatenateExpectation) Then(resultFilepath string, err error) *MediaProcessorMock {
	e.results = &MediaProcessorMockConcatenateResults{resultFilepath, err}
	return e.mock
}

// Times sets number of times MediaProcessor.Concatenate should be invoked
func (mmConcatenate *mMediaProcessorMockConcatenate) Times(n uint64) *mMediaProcessorMockConcatenate {
	if n == 0 {
		mmConcatenate.mock.t.Fatalf("Times of MediaProcessorMock.Concatenate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConcatenate.expectedInvocations, n)
	mmConcatenate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConcatenate
}

func (mmConcatenate *mMediaProcessorMockConcatenate) invocationsDone() bool {
	if len(mmConcatenate.expectations) == 0 && mmConcatenate.defaultExpectation == nil && mmConcatenate.mock.funcConcatenate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConcatenate.mock.afterConcatenateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConcatenate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Concatenate implements mm_service.MediaProcessor
func (mmConcatenate *MediaProcessorMock) Concatenate(ctx context.Context, filepaths []string, audioCodec string) (resultFilepath string, err error) {
	mm_atomic.AddUint64(&mmConcatenate.beforeConcatenateCounter, 1)
	defer mm_atomic.AddUint64(&mmConcatenate.afterConcatenateCounter, 1)

	mmConcatenate.t.Helper()

	if mmConcatenate.inspectFuncConcatenate != nil {
		mmConcatenate.inspectFuncConcatenate(ctx, filepaths, audioCodec)
	}

	mm_params := MediaProcessorMockConcatenateParams{ctx, filepaths, audioCodec}

	// Record call args
	mmConcatenate.ConcatenateMock.mutex.Lock()
	mmConcatenate.ConcatenateMock.callArgs = append(mmConcatenate.ConcatenateMock.callArgs, &mm_params)
	mmConcatenate.ConcatenateMock.mutex.Unlock()

	for _, e := range mmConcatenate.ConcatenateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resultFilepath, e.results.err
		}
	}

	if mmConcatenate.ConcatenateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConcatenate.ConcatenateMock.defaultExpectation.Counter, 1)
		mm_want := mmConcatenate.ConcatenateMock.defaultExpectation.params
		mm_want_ptrs := mmConcatenate.ConcatenateMock.defaultExpectation.paramPtrs

		mm_got := MediaProcessorMockConcatenateParams{ctx, filepaths, audioCodec}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConcatenate.t.Errorf("MediaProcessorMock.Concatenate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConcatenate.ConcatenateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filepaths != nil && !minimock.Equal(*mm_want_ptrs.filepaths, mm_got.filepaths) {
				mmConcatenate.t.Errorf("MediaProcessorMock.Concatenate got unexpected parameter filepaths, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConcatenate.ConcatenateMock.defaultExpectation.expectationOrigins.originFilepaths, *mm_want_ptrs.filepaths, mm_got.filepaths, minimock.Diff(*mm_want_ptrs.filepaths, mm_got.filepaths))
			}

			if mm_want_ptrs.audioCodec != nil && !minimock.Equal(*mm_want_ptrs.audioCodec, mm_got.audioCodec) {
				mmConcatenate.t.Errorf("MediaProcessorMock.Concatenate got unexpected parameter audioCodec, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConcatenate.ConcatenateMock.defaultExpectation.expectationOrigins.originAudioCodec, *mm_want_ptrs.audioCodec, mm_got.audioCodec, minimock.Diff(*mm_want_ptrs.audioCodec, mm_got.audioCodec))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConcatenate.t.Errorf("MediaProcessorMock.Concatenate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConcatenate.ConcatenateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConcatenate.ConcatenateMock.defaultExpectation.results
		if mm_results == nil {
			mmConcatenate.t.Fatal("No results are set for the MediaProcessorMock.Concatenate")
		}
		return (*mm_results).resultFilepath, (*mm_results).err
	}
	if mmConcatenate.funcConcatenate != nil {
		return mmConcatenate.funcConcatenate(ctx, filepaths, audioCodec)
	}
	mmConcatenate.t.Fatalf("Unexpected call to MediaProcessorMock.Concatenate. %v %v %v", ctx, filepaths, audioCodec)
	return
}

// ConcatenateAfterCounter returns a count of finished MediaProcessorMock.Concatenate invocations
func (mmConcatenate *MediaProcessorMock) ConcatenateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConcatenate.afterConcatenateCounter)
}

// ConcatenateBeforeCounter returns a count of MediaProcessorMock.Concatenate invocations
func (mmConcatenate *MediaProcessorMock) ConcatenateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConcatenate.beforeConcatenateCounter)
}

// Calls returns a list of arguments used in each call to MediaProcessorMock.Concatenate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConcatenate *mMediaProcessorMockConcatenate) Calls() []*MediaProcessorMockConcatenateParams {
	mmConcatenate.mutex.RLock()

	argCopy := make([]*MediaProcessorMockConcatenateParams, len(mmConcatenate.callArgs))
	copy(argCopy, mmConcatenate.callArgs)

	mmConcatenate.mutex.RUnlock()

	return argCopy
}

// MinimockConcatenateDone returns true if the count of the Concatenate invocations corresponds
// the number of defined expectations
func (m *MediaProcessorMock) MinimockConcatenateDone() bool {
	if m.ConcatenateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConcatenateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConcatenateMock.invocationsDone()
}

// MinimockConcatenateInspect logs each unmet expectation
func (m *MediaProcessorMock) MinimockConcatenateInspect() {
	for _, e := range m.ConcatenateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MediaProcessorMock.Concatenate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConcatenateCounter := mm_atomic.LoadUint64(&m.afterConcatenateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConcatenateMock.defaultExpectation != nil && afterConcatenateCounter < 1 {
		if m.ConcatenateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MediaProcessorMock.Concatenate at\n%s", m.ConcatenateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MediaProcessorMock.Concatenate at\n%s with params: %#v", m.ConcatenateMock.defaultExpectation.expectationOrigins.origin, *m.ConcatenateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConcatenate != nil && afterConcatenateCounter < 1 {
		m.t.Errorf("Expected call to MediaProcessorMock.Concatenate at\n%s", m.funcConcatenateOrigin)
	}

	if !m.ConcatenateMock.invocationsDone() && afterConcatenateCounter > 0 {
		m.t.Errorf("Expected %d calls to MediaProcessorMock.Concatenate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConcatenateMock.expectedInvocations), m.ConcatenateMock.expectedInvocationsOrigin, afterConcatenateCounter)
	}
}

type mMediaProcessorMockGetInfo struct {
	optional           bool
	mock               *MediaProcessorMock
	defaultExpectation *MediaProcessorMockGetInfoExpectation
	expectations       []*MediaProcessorMockGetInfoExpectation

	callArgs []*MediaProcessorMockGetInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MediaProcessorMockGetInfoExpectation specifies expectation struct of the MediaProcessor.GetInfo
type MediaProcessorMockGetInfoExpectation struct {
	mock               *MediaProcessorMock
	params             *MediaProcessorMockGetInfoParams
	paramPtrs          *MediaProcessorMockGetInfoParamPtrs
	expectationOrigins MediaProcessorMockGetInfoExpectationOrigins
	results            *MediaProcessorMockGetInfoResults
	returnOrigin       string
	Counter            uint64
}

// MediaProcessorMockGetInfoParams contains parameters of the MediaProcessor.GetInfo
type MediaProcessorMockGetInfoParams struct {
	ctx      context.Context
	filepath string
}

// MediaProcessorMockGetInfoParamPtrs contains pointers to parameters of the MediaProcessor.GetInfo
type MediaProcessorMockGetInfoParamPtrs struct {
	ctx      *context.Context
	filepath *string
}

// MediaProcessorMockGetInfoResults contains results of the MediaProcessor.GetInfo
type MediaProcessorMockGetInfoResults struct {
	info *mm_service.MediaInfo
	err  error
}

// MediaProcessorMockGetInfoOrigins contains origins of expectations of the MediaProcessor.GetInfo
type MediaProcessorMockGetInfoExpectationOrigins struct {
	origin         string
	originCtx      string
	originFilepath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInfo *mMediaProcessorMockGetInfo) Optional() *mMediaProcessorMockGetInfo {
	mmGetInfo.optional = true
	return mmGetInfo
}

// Expect sets up expected params for MediaProcessor.GetInfo
func (mmGetInfo *mMediaProcessorMockGetInfo) Expect(ctx context.Context, filepath string) *mMediaProcessorMockGetInfo {
	if mmGetInfo.mock.funcGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Set")
	}

	if mmGetInfo.defaultExpectation == nil {
		mmGetInfo.defaultExpectation = &MediaProcessorMockGetInfoExpectation{}
	}

	if mmGetInfo.defaultExpectation.paramPtrs != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by ExpectParams functions")
	}

	mmGetInfo.defaultExpectation.params = &MediaProcessorMockGetInfoParams{ctx, filepath}
	mmGetInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInfo.expectations {
		if minimock.Equal(e.params, mmGetInfo.defaultExpectation.params) {
			mmGetInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInfo.defaultExpectation.params)
		}
	}

	return mmGetInfo
}

// ExpectCtxParam1 sets up expected param ctx for MediaProcessor.GetInfo
func (mmGetInfo *mMediaProcessorMockGetInfo) ExpectCtxParam1(ctx context.Context) *mMediaProcessorMockGetInfo {
	if mmGetInfo.mock.funcGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Set")
	}

	if mmGetInfo.defaultExpectation == nil {
		mmGetInfo.defaultExpectation = &MediaProcessorMockGetInfoExpectation{}
	}

	if mmGetInfo.defaultExpectation.params != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Expect")
	}

	if mmGetInfo.defaultExpectation.paramPtrs == nil {
		mmGetInfo.defaultExpectation.paramPtrs = &MediaProcessorMockGetInfoParamPtrs{}
	}
	mmGetInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInfo
}

// ExpectFilepathParam2 sets up expected param filepath for MediaProcessor.GetInfo
func (mmGetInfo *mMediaProcessorMockGetInfo) ExpectFilepathParam2(filepath string) *mMediaProcessorMockGetInfo {
	if mmGetInfo.mock.funcGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Set")
	}

	if mmGetInfo.defaultExpectation == nil {
		mmGetInfo.defaultExpectation = &MediaProcessorMockGetInfoExpectation{}
	}

	if mmGetInfo.defaultExpectation.params != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Expect")
	}

	if mmGetInfo.defaultExpectation.paramPtrs == nil {
		mmGetInfo.defaultExpectation.paramPtrs = &MediaProcessorMockGetInfoParamPtrs{}
	}
	mmGetInfo.defaultExpectation.paramPtrs.filepath = &filepath
	mmGetInfo.defaultExpectation.expectationOrigins.originFilepath = minimock.CallerInfo(1)

	return mmGetInfo
}

// Inspect accepts an inspector function that has same arguments as the MediaProcessor.GetInfo
func (mmGetInfo *mMediaProcessorMockGetInfo) Inspect(f func(ctx context.Context, filepath string)) *mMediaProcessorMockGetInfo {
	if mmGetInfo.mock.inspectFuncGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("Inspect function is already set for MediaProcessorMock.GetInfo")
	}

	mmGetInfo.mock.inspectFuncGetInfo = f

	return mmGetInfo
}

// Return sets up results that will be returned by MediaProcessor.GetInfo
func (mmGetInfo *mMediaProcessorMockGetInfo) Return(info *mm_service.MediaInfo, err error) *MediaProcessorMock {
	if mmGetInfo.mock.funcGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Set")
	}

	if mmGetInfo.defaultExpectation == nil {
		mmGetInfo.defaultExpectation = &MediaProcessorMockGetInfoExpectation{mock: mmGetInfo.mock}
	}
	mmGetInfo.defaultExpectation.results = &MediaProcessorMockGetInfoResults{info, err}
	mmGetInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInfo.mock
}

// Set uses given function f to mock the MediaProcessor.GetInfo method
func (mmGetInfo *mMediaProcessorMockGetInfo) Set(f func(ctx context.Context, filepath string) (info *mm_service.MediaInfo, err error)) *MediaProcessorMock {
	if mmGetInfo.defaultExpectation != nil {
		mmGetInfo.mock.t.Fatalf("Default expectation is already set for the MediaProcessor.GetInfo method")
	}

	if len(mmGetInfo.expectations) > 0 {
		mmGetInfo.mock.t.Fatalf("Some expectations are already set for the MediaProcessor.GetInfo method")
	}

	mmGetInfo.mock.funcGetInfo = f
	mmGetInfo.mock.funcGetInfoOrigin = minimock.CallerInfo(1)
	return mmGetInfo.mock
}

// When sets expectation for the MediaProcessor.GetInfo which will trigger the result defined by the following
// Then helper
func (mmGetInfo *mMediaProcessorMockGetInfo) When(ctx context.Context, filepath string) *MediaProcessorMockGetInfoExpectation {
	if mmGetInfo.mock.funcGetInfo != nil {
		mmGetInfo.mock.t.Fatalf("MediaProcessorMock.GetInfo mock is already set by Set")
	}

	expectation := &MediaProcessorMockGetInfoExpectation{
		mock:               mmGetInfo.mock,
		params:             &MediaProcessorMockGetInfoParams{ctx, filepath},
		expectationOrigins: MediaProcessorMockGetInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInfo.expectations = append(mmGetInfo.expectations, expectation)
	return expectation
}

// Then sets up MediaProcessor.GetInfo return parameters for the expectation previously defined by the When method
func (e *MediaProcessorMockGetInfoExpectation) Then(info *mm_service.MediaInfo, err error) *MediaProcessorMock {
	e.results = &MediaProcessorMockGetInfoResults{info, err}
	return e.mock
}

// Times sets number of times MediaProcessor.GetInfo should be invoked
func (mmGetInfo *mMediaProcessorMockGetInfo) Times(n uint64) *mMediaProcessorMockGetInfo {
	if n == 0 {
		mmGetInfo.mock.t.Fatalf("Times of MediaProcessorMock.GetInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInfo.expectedInvocations, n)
	mmGetInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInfo
}

func (mmGetInfo *mMediaProcessorMockGetInfo) invocationsDone() bool {
	if len(mmGetInfo.expectations) == 0 && mmGetInfo.defaultExpectation == nil && mmGetInfo.mock.funcGetInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInfo.mock.afterGetInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInfo implements mm_service.MediaProcessor
func (mmGetInfo *MediaProcessorMock) GetInfo(ctx context.Context, filepath string) (info *mm_service.MediaInfo, err error) {
	mm_atomic.AddUint64(&mmGetInfo.beforeGetInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInfo.afterGetInfoCounter, 1)

	mmGetInfo.t.Helper()

	if mmGetInfo.inspectFuncGetInfo != nil {
		mmGetInfo.inspectFuncGetInfo(ctx, filepath)
	}

	mm_params := MediaProcessorMockGetInfoParams{ctx, filepath}

	// Record call args
	mmGetInfo.GetInfoMock.mutex.Lock()
	mmGetInfo.GetInfoMock.callArgs = append(mmGetInfo.GetInfoMock.callArgs, &mm_params)
	mmGetInfo.GetInfoMock.mutex.Unlock()

	for _, e := range mmGetInfo.GetInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.info, e.results.err
		}
	}

	if mmGetInfo.GetInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInfo.GetInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInfo.GetInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetInfo.GetInfoMock.defaultExpectation.paramPtrs

		mm_got := MediaProcessorMockGetInfoParams{ctx, filepath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInfo.t.Errorf("MediaProcessorMock.GetInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfo.GetInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filepath != nil && !minimock.Equal(*mm_want_ptrs.filepath, mm_got.filepath) {
				mmGetInfo.t.Errorf("MediaProcessorMock.GetInfo got unexpected parameter filepath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfo.GetInfoMock.defaultExpectation.expectationOrigins.originFilepath, *mm_want_ptrs.filepath, mm_got.filepath, minimock.Diff(*mm_want_ptrs.filepath, mm_got.filepath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInfo.t.Errorf("MediaProcessorMock.GetInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInfo.GetInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInfo.GetInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInfo.t.Fatal("No results are set for the MediaProcessorMock.GetInfo")
		}
		return (*mm_results).info, (*mm_results).err
	}
	if mmGetInfo.funcGetInfo != nil {
		return mmGetInfo.funcGetInfo(ctx, filepath)
	}
	mmGetInfo.t.Fatalf("Unexpected call to MediaProcessorMock.GetInfo. %v %v", ctx, filepath)
	return
}

// GetInfoAfterCounter returns a count of finished MediaProcessorMock.GetInfo invocations
func (mmGetInfo *MediaProcessorMock) GetInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfo.afterGetInfoCounter)
}

// GetInfoBeforeCounter returns a count of MediaProcessorMock.GetInfo invocations
func (mmGetInfo *MediaProcessorMock) GetInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfo.beforeGetInfoCounter)
}

// Calls returns a list of arguments used in each call to MediaProcessorMock.GetInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInfo *mMediaProcessorMockGetInfo) Calls() []*MediaProcessorMockGetInfoParams {
	mmGetInfo.mutex.RLock()

	argCopy := make([]*MediaProcessorMockGetInfoParams, len(mmGetInfo.callArgs))
	copy(argCopy, mmGetInfo.callArgs)

	mmGetInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetInfoDone returns true if the count of the GetInfo invocations corresponds
// the number of defined expectations
func (m *MediaProcessorMock) MinimockGetInfoDone() bool {
	if m.GetInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInfoMock.invocationsDone()
}

// MinimockGetInfoInspect logs each unmet expectation
func (m *MediaProcessorMock) MinimockGetInfoInspect() {
	for _, e := range m.GetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MediaProcessorMock.GetInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInfoCounter := mm_atomic.LoadUint64(&m.afterGetInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInfoMock.defaultExpectation != nil && afterGetInfoCounter < 1 {
		if m.GetInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MediaProcessorMock.GetInfo at\n%s", m.GetInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MediaProcessorMock.GetInfo at\n%s with params: %#v", m.GetInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInfo != nil && afterGetInfoCounter < 1 {
		m.t.Errorf("Expected call to MediaProcessorMock.GetInfo at\n%s", m.funcGetInfoOrigin)
	}

	if !m.GetInfoMock.invocationsDone() && afterGetInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to MediaProcessorMock.GetInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInfoMock.expectedInvocations), m.GetInfoMock.expectedInvocationsOrigin, afterGetInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MediaProcessorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddChapterTagsInspect()

			m.MinimockConcatenateInspect()

			m.MinimockGetInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MediaProcessorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MediaProcessorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddChapterTagsDone() &&
		m.MinimockConcatenateDone() &&
		m.MinimockGetInfoDone()
}
