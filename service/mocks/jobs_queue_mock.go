// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// JobsQueueMock implements mm_service.JobsQueue
type JobsQueueMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcPublish          func(ctx context.Context, jobType string, payload any) (err error)
	funcPublishOrigin    string
	inspectFuncPublish   func(ctx context.Context, jobType string, payload any)
	afterPublishCounter  uint64
	beforePublishCounter uint64
	PublishMock          mJobsQueueMockPublish

	funcRun          func()
	funcRunOrigin    string
	inspectFuncRun   func()
	afterRunCounter  uint64
	beforeRunCounter uint64
	RunMock          mJobsQueueMockRun

	funcShutdown          func()
	funcShutdownOrigin    string
	inspectFuncShutdown   func()
	afterShutdownCounter  uint64
	beforeShutdownCounter uint64
	ShutdownMock          mJobsQueueMockShutdown

	funcSubscribe          func(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error)
	funcSubscribeOrigin    string
	inspectFuncSubscribe   func(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error)
	afterSubscribeCounter  uint64
	beforeSubscribeCounter uint64
	SubscribeMock          mJobsQueueMockSubscribe
}

// NewJobsQueueMock returns a mock for mm_service.JobsQueue
func NewJobsQueueMock(t minimock.Tester) *JobsQueueMock {
	m := &JobsQueueMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PublishMock = mJobsQueueMockPublish{mock: m}
	m.PublishMock.callArgs = []*JobsQueueMockPublishParams{}

	m.RunMock = mJobsQueueMockRun{mock: m}

	m.ShutdownMock = mJobsQueueMockShutdown{mock: m}

	m.SubscribeMock = mJobsQueueMockSubscribe{mock: m}
	m.SubscribeMock.callArgs = []*JobsQueueMockSubscribeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJobsQueueMockPublish struct {
	optional           bool
	mock               *JobsQueueMock
	defaultExpectation *JobsQueueMockPublishExpectation
	expectations       []*JobsQueueMockPublishExpectation

	callArgs []*JobsQueueMockPublishParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JobsQueueMockPublishExpectation specifies expectation struct of the JobsQueue.Publish
type JobsQueueMockPublishExpectation struct {
	mock               *JobsQueueMock
	params             *JobsQueueMockPublishParams
	paramPtrs          *JobsQueueMockPublishParamPtrs
	expectationOrigins JobsQueueMockPublishExpectationOrigins
	results            *JobsQueueMockPublishResults
	returnOrigin       string
	Counter            uint64
}

// JobsQueueMockPublishParams contains parameters of the JobsQueue.Publish
type JobsQueueMockPublishParams struct {
	ctx     context.Context
	jobType string
	payload any
}

// JobsQueueMockPublishParamPtrs contains pointers to parameters of the JobsQueue.Publish
type JobsQueueMockPublishParamPtrs struct {
	ctx     *context.Context
	jobType *string
	payload *any
}

// JobsQueueMockPublishResults contains results of the JobsQueue.Publish
type JobsQueueMockPublishResults struct {
	err error
}

// JobsQueueMockPublishOrigins contains origins of expectations of the JobsQueue.Publish
type JobsQueueMockPublishExpectationOrigins struct {
	origin        string
	originCtx     string
	originJobType string
	originPayload string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPublish *mJobsQueueMockPublish) Optional() *mJobsQueueMockPublish {
	mmPublish.optional = true
	return mmPublish
}

// Expect sets up expected params for JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) Expect(ctx context.Context, jobType string, payload any) *mJobsQueueMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &JobsQueueMockPublishExpectation{}
	}

	if mmPublish.defaultExpectation.paramPtrs != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by ExpectParams functions")
	}

	mmPublish.defaultExpectation.params = &JobsQueueMockPublishParams{ctx, jobType, payload}
	mmPublish.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPublish.expectations {
		if minimock.Equal(e.params, mmPublish.defaultExpectation.params) {
			mmPublish.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublish.defaultExpectation.params)
		}
	}

	return mmPublish
}

// ExpectCtxParam1 sets up expected param ctx for JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) ExpectCtxParam1(ctx context.Context) *mJobsQueueMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &JobsQueueMockPublishExpectation{}
	}

	if mmPublish.defaultExpectation.params != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Expect")
	}

	if mmPublish.defaultExpectation.paramPtrs == nil {
		mmPublish.defaultExpectation.paramPtrs = &JobsQueueMockPublishParamPtrs{}
	}
	mmPublish.defaultExpectation.paramPtrs.ctx = &ctx
	mmPublish.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPublish
}

// ExpectJobTypeParam2 sets up expected param jobType for JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) ExpectJobTypeParam2(jobType string) *mJobsQueueMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &JobsQueueMockPublishExpectation{}
	}

	if mmPublish.defaultExpectation.params != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Expect")
	}

	if mmPublish.defaultExpectation.paramPtrs == nil {
		mmPublish.defaultExpectation.paramPtrs = &JobsQueueMockPublishParamPtrs{}
	}
	mmPublish.defaultExpectation.paramPtrs.jobType = &jobType
	mmPublish.defaultExpectation.expectationOrigins.originJobType = minimock.CallerInfo(1)

	return mmPublish
}

// ExpectPayloadParam3 sets up expected param payload for JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) ExpectPayloadParam3(payload any) *mJobsQueueMockPublish {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &JobsQueueMockPublishExpectation{}
	}

	if mmPublish.defaultExpectation.params != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Expect")
	}

	if mmPublish.defaultExpectation.paramPtrs == nil {
		mmPublish.defaultExpectation.paramPtrs = &JobsQueueMockPublishParamPtrs{}
	}
	mmPublish.defaultExpectation.paramPtrs.payload = &payload
	mmPublish.defaultExpectation.expectationOrigins.originPayload = minimock.CallerInfo(1)

	return mmPublish
}

// Inspect accepts an inspector function that has same arguments as the JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) Inspect(f func(ctx context.Context, jobType string, payload any)) *mJobsQueueMockPublish {
	if mmPublish.mock.inspectFuncPublish != nil {
		mmPublish.mock.t.Fatalf("Inspect function is already set for JobsQueueMock.Publish")
	}

	mmPublish.mock.inspectFuncPublish = f

	return mmPublish
}

// Return sets up results that will be returned by JobsQueue.Publish
func (mmPublish *mJobsQueueMockPublish) Return(err error) *JobsQueueMock {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	if mmPublish.defaultExpectation == nil {
		mmPublish.defaultExpectation = &JobsQueueMockPublishExpectation{mock: mmPublish.mock}
	}
	mmPublish.defaultExpectation.results = &JobsQueueMockPublishResults{err}
	mmPublish.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPublish.mock
}

// Set uses given function f to mock the JobsQueue.Publish method
func (mmPublish *mJobsQueueMockPublish) Set(f func(ctx context.Context, jobType string, payload any) (err error)) *JobsQueueMock {
	if mmPublish.defaultExpectation != nil {
		mmPublish.mock.t.Fatalf("Default expectation is already set for the JobsQueue.Publish method")
	}

	if len(mmPublish.expectations) > 0 {
		mmPublish.mock.t.Fatalf("Some expectations are already set for the JobsQueue.Publish method")
	}

	mmPublish.mock.funcPublish = f
	mmPublish.mock.funcPublishOrigin = minimock.CallerInfo(1)
	return mmPublish.mock
}

// When sets expectation for the JobsQueue.Publish which will trigger the result defined by the following
// Then helper
func (mmPublish *mJobsQueueMockPublish) When(ctx context.Context, jobType string, payload any) *JobsQueueMockPublishExpectation {
	if mmPublish.mock.funcPublish != nil {
		mmPublish.mock.t.Fatalf("JobsQueueMock.Publish mock is already set by Set")
	}

	expectation := &JobsQueueMockPublishExpectation{
		mock:               mmPublish.mock,
		params:             &JobsQueueMockPublishParams{ctx, jobType, payload},
		expectationOrigins: JobsQueueMockPublishExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPublish.expectations = append(mmPublish.expectations, expectation)
	return expectation
}

// Then sets up JobsQueue.Publish return parameters for the expectation previously defined by the When method
func (e *JobsQueueMockPublishExpectation) Then(err error) *JobsQueueMock {
	e.results = &JobsQueueMockPublishResults{err}
	return e.mock
}

// Times sets number of times JobsQueue.Publish should be invoked
func (mmPublish *mJobsQueueMockPublish) Times(n uint64) *mJobsQueueMockPublish {
	if n == 0 {
		mmPublish.mock.t.Fatalf("Times of JobsQueueMock.Publish mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPublish.expectedInvocations, n)
	mmPublish.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPublish
}

func (mmPublish *mJobsQueueMockPublish) invocationsDone() bool {
	if len(mmPublish.expectations) == 0 && mmPublish.defaultExpectation == nil && mmPublish.mock.funcPublish == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPublish.mock.afterPublishCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPublish.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Publish implements mm_service.JobsQueue
func (mmPublish *JobsQueueMock) Publish(ctx context.Context, jobType string, payload any) (err error) {
	mm_atomic.AddUint64(&mmPublish.beforePublishCounter, 1)
	defer mm_atomic.AddUint64(&mmPublish.afterPublishCounter, 1)

	mmPublish.t.Helper()

	if mmPublish.inspectFuncPublish != nil {
		mmPublish.inspectFuncPublish(ctx, jobType, payload)
	}

	mm_params := JobsQueueMockPublishParams{ctx, jobType, payload}

	// Record call args
	mmPublish.PublishMock.mutex.Lock()
	mmPublish.PublishMock.callArgs = append(mmPublish.PublishMock.callArgs, &mm_params)
	mmPublish.PublishMock.mutex.Unlock()

	for _, e := range mmPublish.PublishMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPublish.PublishMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublish.PublishMock.defaultExpectation.Counter, 1)
		mm_want := mmPublish.PublishMock.defaultExpectation.params
		mm_want_ptrs := mmPublish.PublishMock.defaultExpectation.paramPtrs

		mm_got := JobsQueueMockPublishParams{ctx, jobType, payload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPublish.t.Errorf("JobsQueueMock.Publish got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublish.PublishMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.jobType != nil && !minimock.Equal(*mm_want_ptrs.jobType, mm_got.jobType) {
				mmPublish.t.Errorf("JobsQueueMock.Publish got unexpected parameter jobType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublish.PublishMock.defaultExpectation.expectationOrigins.originJobType, *mm_want_ptrs.jobType, mm_got.jobType, minimock.Diff(*mm_want_ptrs.jobType, mm_got.jobType))
			}

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmPublish.t.Errorf("JobsQueueMock.Publish got unexpected parameter payload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublish.PublishMock.defaultExpectation.expectationOrigins.originPayload, *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublish.t.Errorf("JobsQueueMock.Publish got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPublish.PublishMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublish.PublishMock.defaultExpectation.results
		if mm_results == nil {
			mmPublish.t.Fatal("No results are set for the JobsQueueMock.Publish")
		}
		return (*mm_results).err
	}
	if mmPublish.funcPublish != nil {
		return mmPublish.funcPublish(ctx, jobType, payload)
	}
	mmPublish.t.Fatalf("Unexpected call to JobsQueueMock.Publish. %v %v %v", ctx, jobType, payload)
	return
}

// PublishAfterCounter returns a count of finished JobsQueueMock.Publish invocations
func (mmPublish *JobsQueueMock) PublishAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.afterPublishCounter)
}

// PublishBeforeCounter returns a count of JobsQueueMock.Publish invocations
func (mmPublish *JobsQueueMock) PublishBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublish.beforePublishCounter)
}

// Calls returns a list of arguments used in each call to JobsQueueMock.Publish.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublish *mJobsQueueMockPublish) Calls() []*JobsQueueMockPublishParams {
	mmPublish.mutex.RLock()

	argCopy := make([]*JobsQueueMockPublishParams, len(mmPublish.callArgs))
	copy(argCopy, mmPublish.callArgs)

	mmPublish.mutex.RUnlock()

	return argCopy
}

// MinimockPublishDone returns true if the count of the Publish invocations corresponds
// the number of defined expectations
func (m *JobsQueueMock) MinimockPublishDone() bool {
	if m.PublishMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PublishMock.invocationsDone()
}

// MinimockPublishInspect logs each unmet expectation
func (m *JobsQueueMock) MinimockPublishInspect() {
	for _, e := range m.PublishMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JobsQueueMock.Publish at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPublishCounter := mm_atomic.LoadUint64(&m.afterPublishCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMock.defaultExpectation != nil && afterPublishCounter < 1 {
		if m.PublishMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JobsQueueMock.Publish at\n%s", m.PublishMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JobsQueueMock.Publish at\n%s with params: %#v", m.PublishMock.defaultExpectation.expectationOrigins.origin, *m.PublishMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublish != nil && afterPublishCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Publish at\n%s", m.funcPublishOrigin)
	}

	if !m.PublishMock.invocationsDone() && afterPublishCounter > 0 {
		m.t.Errorf("Expected %d calls to JobsQueueMock.Publish at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PublishMock.expectedInvocations), m.PublishMock.expectedInvocationsOrigin, afterPublishCounter)
	}
}

type mJobsQueueMockRun struct {
	optional           bool
	mock               *JobsQueueMock
	defaultExpectation *JobsQueueMockRunExpectation
	expectations       []*JobsQueueMockRunExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JobsQueueMockRunExpectation specifies expectation struct of the JobsQueue.Run
type JobsQueueMockRunExpectation struct {
	mock *JobsQueueMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRun *mJobsQueueMockRun) Optional() *mJobsQueueMockRun {
	mmRun.optional = true
	return mmRun
}

// Expect sets up expected params for JobsQueue.Run
func (mmRun *mJobsQueueMockRun) Expect() *mJobsQueueMockRun {
	if mmRun.mock.funcRun != nil {
		mmRun.mock.t.Fatalf("JobsQueueMock.Run mock is already set by Set")
	}

	if mmRun.defaultExpectation == nil {
		mmRun.defaultExpectation = &JobsQueueMockRunExpectation{}
	}

	return mmRun
}

// Inspect accepts an inspector function that has same arguments as the JobsQueue.Run
func (mmRun *mJobsQueueMockRun) Inspect(f func()) *mJobsQueueMockRun {
	if mmRun.mock.inspectFuncRun != nil {
		mmRun.mock.t.Fatalf("Inspect function is already set for JobsQueueMock.Run")
	}

	mmRun.mock.inspectFuncRun = f

	return mmRun
}

// Return sets up results that will be returned by JobsQueue.Run
func (mmRun *mJobsQueueMockRun) Return() *JobsQueueMock {
	if mmRun.mock.funcRun != nil {
		mmRun.mock.t.Fatalf("JobsQueueMock.Run mock is already set by Set")
	}

	if mmRun.defaultExpectation == nil {
		mmRun.defaultExpectation = &JobsQueueMockRunExpectation{mock: mmRun.mock}
	}

	mmRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRun.mock
}

// Set uses given function f to mock the JobsQueue.Run method
func (mmRun *mJobsQueueMockRun) Set(f func()) *JobsQueueMock {
	if mmRun.defaultExpectation != nil {
		mmRun.mock.t.Fatalf("Default expectation is already set for the JobsQueue.Run method")
	}

	if len(mmRun.expectations) > 0 {
		mmRun.mock.t.Fatalf("Some expectations are already set for the JobsQueue.Run method")
	}

	mmRun.mock.funcRun = f
	mmRun.mock.funcRunOrigin = minimock.CallerInfo(1)
	return mmRun.mock
}

// Times sets number of times JobsQueue.Run should be invoked
func (mmRun *mJobsQueueMockRun) Times(n uint64) *mJobsQueueMockRun {
	if n == 0 {
		mmRun.mock.t.Fatalf("Times of JobsQueueMock.Run mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRun.expectedInvocations, n)
	mmRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRun
}

func (mmRun *mJobsQueueMockRun) invocationsDone() bool {
	if len(mmRun.expectations) == 0 && mmRun.defaultExpectation == nil && mmRun.mock.funcRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRun.mock.afterRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Run implements mm_service.JobsQueue
func (mmRun *JobsQueueMock) Run() {
	mm_atomic.AddUint64(&mmRun.beforeRunCounter, 1)
	defer mm_atomic.AddUint64(&mmRun.afterRunCounter, 1)

	mmRun.t.Helper()

	if mmRun.inspectFuncRun != nil {
		mmRun.inspectFuncRun()
	}

	if mmRun.RunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRun.RunMock.defaultExpectation.Counter, 1)

		return

	}
	if mmRun.funcRun != nil {
		mmRun.funcRun()
		return
	}
	mmRun.t.Fatalf("Unexpected call to JobsQueueMock.Run.")

}

// RunAfterCounter returns a count of finished JobsQueueMock.Run invocations
func (mmRun *JobsQueueMock) RunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRun.afterRunCounter)
}

// RunBeforeCounter returns a count of JobsQueueMock.Run invocations
func (mmRun *JobsQueueMock) RunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRun.beforeRunCounter)
}

// MinimockRunDone returns true if the count of the Run invocations corresponds
// the number of defined expectations
func (m *JobsQueueMock) MinimockRunDone() bool {
	if m.RunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RunMock.invocationsDone()
}

// MinimockRunInspect logs each unmet expectation
func (m *JobsQueueMock) MinimockRunInspect() {
	for _, e := range m.RunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JobsQueueMock.Run")
		}
	}

	afterRunCounter := mm_atomic.LoadUint64(&m.afterRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RunMock.defaultExpectation != nil && afterRunCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Run at\n%s", m.RunMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRun != nil && afterRunCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Run at\n%s", m.funcRunOrigin)
	}

	if !m.RunMock.invocationsDone() && afterRunCounter > 0 {
		m.t.Errorf("Expected %d calls to JobsQueueMock.Run at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RunMock.expectedInvocations), m.RunMock.expectedInvocationsOrigin, afterRunCounter)
	}
}

type mJobsQueueMockShutdown struct {
	optional           bool
	mock               *JobsQueueMock
	defaultExpectation *JobsQueueMockShutdownExpectation
	expectations       []*JobsQueueMockShutdownExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JobsQueueMockShutdownExpectation specifies expectation struct of the JobsQueue.Shutdown
type JobsQueueMockShutdownExpectation struct {
	mock *JobsQueueMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmShutdown *mJobsQueueMockShutdown) Optional() *mJobsQueueMockShutdown {
	mmShutdown.optional = true
	return mmShutdown
}

// Expect sets up expected params for JobsQueue.Shutdown
func (mmShutdown *mJobsQueueMockShutdown) Expect() *mJobsQueueMockShutdown {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("JobsQueueMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &JobsQueueMockShutdownExpectation{}
	}

	return mmShutdown
}

// Inspect accepts an inspector function that has same arguments as the JobsQueue.Shutdown
func (mmShutdown *mJobsQueueMockShutdown) Inspect(f func()) *mJobsQueueMockShutdown {
	if mmShutdown.mock.inspectFuncShutdown != nil {
		mmShutdown.mock.t.Fatalf("Inspect function is already set for JobsQueueMock.Shutdown")
	}

	mmShutdown.mock.inspectFuncShutdown = f

	return mmShutdown
}

// Return sets up results that will be returned by JobsQueue.Shutdown
func (mmShutdown *mJobsQueueMockShutdown) Return() *JobsQueueMock {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("JobsQueueMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &JobsQueueMockShutdownExpectation{mock: mmShutdown.mock}
	}

	mmShutdown.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmShutdown.mock
}

// Set uses given function f to mock the JobsQueue.Shutdown method
func (mmShutdown *mJobsQueueMockShutdown) Set(f func()) *JobsQueueMock {
	if mmShutdown.defaultExpectation != nil {
		mmShutdown.mock.t.Fatalf("Default expectation is already set for the JobsQueue.Shutdown method")
	}

	if len(mmShutdown.expectations) > 0 {
		mmShutdown.mock.t.Fatalf("Some expectations are already set for the JobsQueue.Shutdown method")
	}

	mmShutdown.mock.funcShutdown = f
	mmShutdown.mock.funcShutdownOrigin = minimock.CallerInfo(1)
	return mmShutdown.mock
}

// Times sets number of times JobsQueue.Shutdown should be invoked
func (mmShutdown *mJobsQueueMockShutdown) Times(n uint64) *mJobsQueueMockShutdown {
	if n == 0 {
		mmShutdown.mock.t.Fatalf("Times of JobsQueueMock.Shutdown mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmShutdown.expectedInvocations, n)
	mmShutdown.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmShutdown
}

func (mmShutdown *mJobsQueueMockShutdown) invocationsDone() bool {
	if len(mmShutdown.expectations) == 0 && mmShutdown.defaultExpectation == nil && mmShutdown.mock.funcShutdown == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmShutdown.mock.afterShutdownCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmShutdown.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Shutdown implements mm_service.JobsQueue
func (mmShutdown *JobsQueueMock) Shutdown() {
	mm_atomic.AddUint64(&mmShutdown.beforeShutdownCounter, 1)
	defer mm_atomic.AddUint64(&mmShutdown.afterShutdownCounter, 1)

	mmShutdown.t.Helper()

	if mmShutdown.inspectFuncShutdown != nil {
		mmShutdown.inspectFuncShutdown()
	}

	if mmShutdown.ShutdownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShutdown.ShutdownMock.defaultExpectation.Counter, 1)

		return

	}
	if mmShutdown.funcShutdown != nil {
		mmShutdown.funcShutdown()
		return
	}
	mmShutdown.t.Fatalf("Unexpected call to JobsQueueMock.Shutdown.")

}

// ShutdownAfterCounter returns a count of finished JobsQueueMock.Shutdown invocations
func (mmShutdown *JobsQueueMock) ShutdownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.afterShutdownCounter)
}

// ShutdownBeforeCounter returns a count of JobsQueueMock.Shutdown invocations
func (mmShutdown *JobsQueueMock) ShutdownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.beforeShutdownCounter)
}

// MinimockShutdownDone returns true if the count of the Shutdown invocations corresponds
// the number of defined expectations
func (m *JobsQueueMock) MinimockShutdownDone() bool {
	if m.ShutdownMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ShutdownMock.invocationsDone()
}

// MinimockShutdownInspect logs each unmet expectation
func (m *JobsQueueMock) MinimockShutdownInspect() {
	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to JobsQueueMock.Shutdown")
		}
	}

	afterShutdownCounter := mm_atomic.LoadUint64(&m.afterShutdownCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ShutdownMock.defaultExpectation != nil && afterShutdownCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Shutdown at\n%s", m.ShutdownMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutdown != nil && afterShutdownCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Shutdown at\n%s", m.funcShutdownOrigin)
	}

	if !m.ShutdownMock.invocationsDone() && afterShutdownCounter > 0 {
		m.t.Errorf("Expected %d calls to JobsQueueMock.Shutdown at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ShutdownMock.expectedInvocations), m.ShutdownMock.expectedInvocationsOrigin, afterShutdownCounter)
	}
}

type mJobsQueueMockSubscribe struct {
	optional           bool
	mock               *JobsQueueMock
	defaultExpectation *JobsQueueMockSubscribeExpectation
	expectations       []*JobsQueueMockSubscribeExpectation

	callArgs []*JobsQueueMockSubscribeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JobsQueueMockSubscribeExpectation specifies expectation struct of the JobsQueue.Subscribe
type JobsQueueMockSubscribeExpectation struct {
	mock               *JobsQueueMock
	params             *JobsQueueMockSubscribeParams
	paramPtrs          *JobsQueueMockSubscribeParamPtrs
	expectationOrigins JobsQueueMockSubscribeExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// JobsQueueMockSubscribeParams contains parameters of the JobsQueue.Subscribe
type JobsQueueMockSubscribeParams struct {
	ctx     context.Context
	jobType string
	f       func(ctx context.Context, payloadBytes []byte) error
}

// JobsQueueMockSubscribeParamPtrs contains pointers to parameters of the JobsQueue.Subscribe
type JobsQueueMockSubscribeParamPtrs struct {
	ctx     *context.Context
	jobType *string
	f       *func(ctx context.Context, payloadBytes []byte) error
}

// JobsQueueMockSubscribeOrigins contains origins of expectations of the JobsQueue.Subscribe
type JobsQueueMockSubscribeExpectationOrigins struct {
	origin        string
	originCtx     string
	originJobType string
	originF       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSubscribe *mJobsQueueMockSubscribe) Optional() *mJobsQueueMockSubscribe {
	mmSubscribe.optional = true
	return mmSubscribe
}

// Expect sets up expected params for JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) Expect(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error) *mJobsQueueMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &JobsQueueMockSubscribeExpectation{}
	}

	if mmSubscribe.defaultExpectation.paramPtrs != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by ExpectParams functions")
	}

	mmSubscribe.defaultExpectation.params = &JobsQueueMockSubscribeParams{ctx, jobType, f}
	mmSubscribe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSubscribe.expectations {
		if minimock.Equal(e.params, mmSubscribe.defaultExpectation.params) {
			mmSubscribe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribe.defaultExpectation.params)
		}
	}

	return mmSubscribe
}

// ExpectCtxParam1 sets up expected param ctx for JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) ExpectCtxParam1(ctx context.Context) *mJobsQueueMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &JobsQueueMockSubscribeExpectation{}
	}

	if mmSubscribe.defaultExpectation.params != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Expect")
	}

	if mmSubscribe.defaultExpectation.paramPtrs == nil {
		mmSubscribe.defaultExpectation.paramPtrs = &JobsQueueMockSubscribeParamPtrs{}
	}
	mmSubscribe.defaultExpectation.paramPtrs.ctx = &ctx
	mmSubscribe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSubscribe
}

// ExpectJobTypeParam2 sets up expected param jobType for JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) ExpectJobTypeParam2(jobType string) *mJobsQueueMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &JobsQueueMockSubscribeExpectation{}
	}

	if mmSubscribe.defaultExpectation.params != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Expect")
	}

	if mmSubscribe.defaultExpectation.paramPtrs == nil {
		mmSubscribe.defaultExpectation.paramPtrs = &JobsQueueMockSubscribeParamPtrs{}
	}
	mmSubscribe.defaultExpectation.paramPtrs.jobType = &jobType
	mmSubscribe.defaultExpectation.expectationOrigins.originJobType = minimock.CallerInfo(1)

	return mmSubscribe
}

// ExpectFParam3 sets up expected param f for JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) ExpectFParam3(f func(ctx context.Context, payloadBytes []byte) error) *mJobsQueueMockSubscribe {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &JobsQueueMockSubscribeExpectation{}
	}

	if mmSubscribe.defaultExpectation.params != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Expect")
	}

	if mmSubscribe.defaultExpectation.paramPtrs == nil {
		mmSubscribe.defaultExpectation.paramPtrs = &JobsQueueMockSubscribeParamPtrs{}
	}
	mmSubscribe.defaultExpectation.paramPtrs.f = &f
	mmSubscribe.defaultExpectation.expectationOrigins.originF = minimock.CallerInfo(1)

	return mmSubscribe
}

// Inspect accepts an inspector function that has same arguments as the JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) Inspect(f func(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error)) *mJobsQueueMockSubscribe {
	if mmSubscribe.mock.inspectFuncSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("Inspect function is already set for JobsQueueMock.Subscribe")
	}

	mmSubscribe.mock.inspectFuncSubscribe = f

	return mmSubscribe
}

// Return sets up results that will be returned by JobsQueue.Subscribe
func (mmSubscribe *mJobsQueueMockSubscribe) Return() *JobsQueueMock {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	if mmSubscribe.defaultExpectation == nil {
		mmSubscribe.defaultExpectation = &JobsQueueMockSubscribeExpectation{mock: mmSubscribe.mock}
	}

	mmSubscribe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSubscribe.mock
}

// Set uses given function f to mock the JobsQueue.Subscribe method
func (mmSubscribe *mJobsQueueMockSubscribe) Set(f func(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error)) *JobsQueueMock {
	if mmSubscribe.defaultExpectation != nil {
		mmSubscribe.mock.t.Fatalf("Default expectation is already set for the JobsQueue.Subscribe method")
	}

	if len(mmSubscribe.expectations) > 0 {
		mmSubscribe.mock.t.Fatalf("Some expectations are already set for the JobsQueue.Subscribe method")
	}

	mmSubscribe.mock.funcSubscribe = f
	mmSubscribe.mock.funcSubscribeOrigin = minimock.CallerInfo(1)
	return mmSubscribe.mock
}

// When sets expectation for the JobsQueue.Subscribe which will trigger the result defined by the following
// Then helper
func (mmSubscribe *mJobsQueueMockSubscribe) When(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error) *JobsQueueMockSubscribeExpectation {
	if mmSubscribe.mock.funcSubscribe != nil {
		mmSubscribe.mock.t.Fatalf("JobsQueueMock.Subscribe mock is already set by Set")
	}

	expectation := &JobsQueueMockSubscribeExpectation{
		mock:               mmSubscribe.mock,
		params:             &JobsQueueMockSubscribeParams{ctx, jobType, f},
		expectationOrigins: JobsQueueMockSubscribeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSubscribe.expectations = append(mmSubscribe.expectations, expectation)
	return expectation
}

// Then sets up JobsQueue.Subscribe return parameters for the expectation previously defined by the When method

func (e *JobsQueueMockSubscribeExpectation) Then() *JobsQueueMock {
	return e.mock
}

// Times sets number of times JobsQueue.Subscribe should be invoked
func (mmSubscribe *mJobsQueueMockSubscribe) Times(n uint64) *mJobsQueueMockSubscribe {
	if n == 0 {
		mmSubscribe.mock.t.Fatalf("Times of JobsQueueMock.Subscribe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSubscribe.expectedInvocations, n)
	mmSubscribe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSubscribe
}

func (mmSubscribe *mJobsQueueMockSubscribe) invocationsDone() bool {
	if len(mmSubscribe.expectations) == 0 && mmSubscribe.defaultExpectation == nil && mmSubscribe.mock.funcSubscribe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSubscribe.mock.afterSubscribeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSubscribe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Subscribe implements mm_service.JobsQueue
func (mmSubscribe *JobsQueueMock) Subscribe(ctx context.Context, jobType string, f func(ctx context.Context, payloadBytes []byte) error) {
	mm_atomic.AddUint64(&mmSubscribe.beforeSubscribeCounter, 1)
	defer mm_atomic.AddUint64(&mmSubscribe.afterSubscribeCounter, 1)

	mmSubscribe.t.Helper()

	if mmSubscribe.inspectFuncSubscribe != nil {
		mmSubscribe.inspectFuncSubscribe(ctx, jobType, f)
	}

	mm_params := JobsQueueMockSubscribeParams{ctx, jobType, f}

	// Record call args
	mmSubscribe.SubscribeMock.mutex.Lock()
	mmSubscribe.SubscribeMock.callArgs = append(mmSubscribe.SubscribeMock.callArgs, &mm_params)
	mmSubscribe.SubscribeMock.mutex.Unlock()

	for _, e := range mmSubscribe.SubscribeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSubscribe.SubscribeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribe.SubscribeMock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribe.SubscribeMock.defaultExpectation.params
		mm_want_ptrs := mmSubscribe.SubscribeMock.defaultExpectation.paramPtrs

		mm_got := JobsQueueMockSubscribeParams{ctx, jobType, f}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSubscribe.t.Errorf("JobsQueueMock.Subscribe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubscribe.SubscribeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.jobType != nil && !minimock.Equal(*mm_want_ptrs.jobType, mm_got.jobType) {
				mmSubscribe.t.Errorf("JobsQueueMock.Subscribe got unexpected parameter jobType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubscribe.SubscribeMock.defaultExpectation.expectationOrigins.originJobType, *mm_want_ptrs.jobType, mm_got.jobType, minimock.Diff(*mm_want_ptrs.jobType, mm_got.jobType))
			}

			if mm_want_ptrs.f != nil && !minimock.Equal(*mm_want_ptrs.f, mm_got.f) {
				mmSubscribe.t.Errorf("JobsQueueMock.Subscribe got unexpected parameter f, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSubscribe.SubscribeMock.defaultExpectation.expectationOrigins.originF, *mm_want_ptrs.f, mm_got.f, minimock.Diff(*mm_want_ptrs.f, mm_got.f))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribe.t.Errorf("JobsQueueMock.Subscribe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSubscribe.SubscribeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSubscribe.funcSubscribe != nil {
		mmSubscribe.funcSubscribe(ctx, jobType, f)
		return
	}
	mmSubscribe.t.Fatalf("Unexpected call to JobsQueueMock.Subscribe. %v %v %v", ctx, jobType, f)

}

// SubscribeAfterCounter returns a count of finished JobsQueueMock.Subscribe invocations
func (mmSubscribe *JobsQueueMock) SubscribeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.afterSubscribeCounter)
}

// SubscribeBeforeCounter returns a count of JobsQueueMock.Subscribe invocations
func (mmSubscribe *JobsQueueMock) SubscribeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribe.beforeSubscribeCounter)
}

// Calls returns a list of arguments used in each call to JobsQueueMock.Subscribe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribe *mJobsQueueMockSubscribe) Calls() []*JobsQueueMockSubscribeParams {
	mmSubscribe.mutex.RLock()

	argCopy := make([]*JobsQueueMockSubscribeParams, len(mmSubscribe.callArgs))
	copy(argCopy, mmSubscribe.callArgs)

	mmSubscribe.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeDone returns true if the count of the Subscribe invocations corresponds
// the number of defined expectations
func (m *JobsQueueMock) MinimockSubscribeDone() bool {
	if m.SubscribeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SubscribeMock.invocationsDone()
}

// MinimockSubscribeInspect logs each unmet expectation
func (m *JobsQueueMock) MinimockSubscribeInspect() {
	for _, e := range m.SubscribeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JobsQueueMock.Subscribe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSubscribeCounter := mm_atomic.LoadUint64(&m.afterSubscribeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeMock.defaultExpectation != nil && afterSubscribeCounter < 1 {
		if m.SubscribeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JobsQueueMock.Subscribe at\n%s", m.SubscribeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JobsQueueMock.Subscribe at\n%s with params: %#v", m.SubscribeMock.defaultExpectation.expectationOrigins.origin, *m.SubscribeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribe != nil && afterSubscribeCounter < 1 {
		m.t.Errorf("Expected call to JobsQueueMock.Subscribe at\n%s", m.funcSubscribeOrigin)
	}

	if !m.SubscribeMock.invocationsDone() && afterSubscribeCounter > 0 {
		m.t.Errorf("Expected %d calls to JobsQueueMock.Subscribe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SubscribeMock.expectedInvocations), m.SubscribeMock.expectedInvocationsOrigin, afterSubscribeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JobsQueueMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockPublishInspect()

			m.MinimockRunInspect()

			m.MinimockShutdownInspect()

			m.MinimockSubscribeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JobsQueueMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JobsQueueMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPublishDone() &&
		m.MinimockRunDone() &&
		m.MinimockShutdownDone() &&
		m.MinimockSubscribeDone()
}
