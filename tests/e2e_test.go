package tests

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/dir01/mediary/downloader/torrent"
	http2 "github.com/dir01/mediary/http"
	"github.com/dir01/mediary/media_processor"
	"github.com/dir01/mediary/service"
	"github.com/dir01/mediary/service/jobs_queue"
	"github.com/dir01/mediary/storage"
	"github.com/dir01/mediary/uploader"
	"github.com/go-redis/redis"
	"go.uber.org/zap"
)

var logger, _ = zap.NewDevelopment()

const (
	magnetURL      = "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65"
	testBucketName = "some-bucket"
)

func TestApplication(t *testing.T) {
	s3Client, err := getS3Client(context.Background(), testBucketName)
	if err != nil {
		t.Fatalf("error creating s3 client: %v", err)
	}

	downloader, err := torrent.NewTorrentDownloader(os.TempDir(), logger)
	if err != nil {
		t.Fatalf("error creating torrent downloader: %v", err)
	}

	redisURL, err := getFakeRedisURL(context.Background())
	if err != nil {
		t.Fatalf("error getting redis url: %v", err)
	}
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		t.Fatalf("error parsing redis url: %v", err)
	}
	redisClient := redis.NewClient(opt)
	defer func() { _ = redisClient.Close() }()

	queue, err := jobs_queue.NewRedisJobsQueue(redisClient, 10, "mediary:")
	if err != nil {
		t.Fatalf("error initializing redis jobs queue: %v", err)
	}

	store := storage.NewStorageInMemory()
	mediaProcessor, err := media_processor.NewFFMpegMediaProcessor(logger)
	if err != nil {
		t.Fatalf("error creating media processor: %v", err)
	}

	upl, err := uploader.New()
	if err != nil {
		t.Fatalf("error creating uploader: %v", err)
	}

	svc := service.NewService(downloader, store, queue, mediaProcessor, upl, logger)
	mux := http2.PrepareHTTPServerMux(svc)

	docs := newDocsHelper(
		t, mux, "../README.md",
		"<!-- start autogenerated samples -->",
		"<!-- stop autogenerated samples -->",
	)
	defer docs.Finish()

	t.Run("metadata with timeout", func(t *testing.T) {
		expectedResponse := `{"status": "accepted"}`
		docs.InsertText(`### '''/metadata''' - Timeouts

By default, the endpoint will timeout pretty quickly, 
probably sooner than it takes to fetch metadata of a torrent, for example.

In such cases, the endpoint will return a '''202 Accepted''' status code and a message '''%s'''

Feel free to repeat your request later: metadata is still being fetched in background.
`, expectedResponse)

		docs.PerformRequestForDocs("GET",
			`/metadata?url=`+magnetURL,
			nil,
			http.StatusAccepted,
			func(rr *httptest.ResponseRecorder) {
				if rr.Body.String() != expectedResponse {
					fmt.Println(rr.Body.String())
					t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expectedResponse)
				}
			},
		)
	})

	t.Run("metadata with long-polling", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		docs.InsertText(`### '''/metadata/long-polling'''

In case you'd rather wait for the metadata to be fetched, you can use the long-polling endpoint.

It will not return a response until the metadata is fetched.

There is still a timeout on the request, but it's pretty long (5 minutes).`)

		docs.PerformRequestForDocs("GET",
			`/metadata/long-polling?url=`+magnetURL,
			nil,
			http.StatusOK,
			func(rr *httptest.ResponseRecorder) {
				if rr.Body.String() != expectedResponse {
					fmt.Println(rr.Body.String())
					t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expectedResponse)
				}
			},
		)
	})

	t.Run("cached metadata", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		docs.InsertText(`### '''/metadata''' - Cached

It goes without saying, that once the metadata is fetched, it is cached.

So all consecutive requests for the same URL will return the same metadata, and immediately.`)

		docs.PerformRequestForDocs(
			"GET",
			`/metadata?url=`+magnetURL,
			nil,
			http.StatusOK,
			func(rr *httptest.ResponseRecorder) {
				if rr.Body.String() != expectedResponse {
					fmt.Println(rr.Body.String())
					t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expectedResponse)
				}
			},
		)
	})

	t.Run("job creation and status", func(t *testing.T) {
		docs.InsertText(`### '''/jobs''' 

POST to '''/jobs''' will schedule for background execution a process of downloading, converting/processing and uploading the media.
Only required parameters are '''url''' and '''type'''. '''type''' signifies the type of operation to be performed. 
Each operation can require some additional parameters, passed as '''params'''. For example, '''concatenate''' job
requires a list of files to be concatenated and, optionally, an '''audioCoded''' to be used for the output file.`)
		req, _ := s3Client.PutObjectRequest(&s3.PutObjectInput{
			Bucket: aws.String(testBucketName),
			Key:    aws.String("/some-file.ext"),
		})
		urlStr, err := req.Presign(90 * time.Minute)
		if err != nil {
			t.Errorf("Failed to sign request: %v", err)
		}

		//if err = UploadFile(urlStr); err != nil {
		//	t.Fatalf("Failed to upload file: %v", err)
		//}
		//fmt.Println("done")
		//return

		payload := strings.NewReader(fmt.Sprintf(`{
			"url": "%s",
			"type": "concatenate",
			"params": {
				"filepaths": [
					"01-001.mp3",
					"01-002.mp3"
				],
				"audioCodec": "mp3",
				"uploadUrl": "%s"
			}
		}`, "magnet:?xt=urn:btih:58C665647C1A34019A0DC99C9046BD459F006B73&tr=http%3A%2F%2Fbt3.t-ru.org", urlStr,
		))

		var jobID string
		docs.PerformRequestForDocs(
			"POST",
			"/jobs",
			payload,
			http.StatusAccepted,
			func(rr *httptest.ResponseRecorder) {
				var job struct {
					ID string `json:"id"`
				}
				err := json.Unmarshal(rr.Body.Bytes(), &job)
				if err != nil {
					t.Errorf("failed to unmarshal job ID: %s", err)
				}
				jobID = job.ID
			},
		)

		docs.InsertText(`### '''/jobs/:id'''

Since jobs can run for a long time, job creation api responds immediately with a job ID.
To check the status of the job, you can use the '''/jobs/:id''' endpoint.`)

		ctx, cancel := context.WithTimeout(context.Background(), 50*time.Minute)
		defer cancel()

		var jobStatus string
		startTime := time.Now()
	loop:
		for {
			select {
			case <-ctx.Done():
				t.Errorf("job %s did not finish in time", jobID)
				break loop
			case <-time.After(100 * time.Millisecond):

				docs.PerformRequest("GET", "/jobs/"+jobID, nil, http.StatusOK, func(rr *httptest.ResponseRecorder) {
					var job struct {
						Status string `json:"status"`
					}
					err := json.Unmarshal(rr.Body.Bytes(), &job)
					if err != nil {
						t.Errorf("failed to unmarshal job ID: %s", err)
					}
					if job.Status != jobStatus {
						if jobStatus == "" {
							docs.InsertText("%s after starting the job:", time.Since(startTime).Round(time.Second))
						} else {
							docs.InsertText("%s later:", time.Since(startTime).Round(time.Second))
						}
						startTime = time.Now()
						jobStatus = job.Status
						docs.PerformRequestForDocs("GET", "/jobs/"+jobID, nil, http.StatusOK, nil)
					}
				})
				if jobStatus == "complete" {
					break loop
				}
			}
		}
	})
}

func UploadFile(url string) error {
	const filepath = "/var/folders/28/6zntdkl10655__7b7_d5yp2w0000gp/T/1586302608.mp3"
	file, err := os.Open(filepath)
	if err != nil {
		return fmt.Errorf("error opening file: %w", err)
	}
	defer file.Close()

	req, err := http.NewRequest("PUT", url, file)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	fileStat, err := os.Stat(filepath)
	if err != nil {
		return fmt.Errorf("failed to get file stat: %w", err)
	}
	req.ContentLength = fileStat.Size()

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed sending request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		bytes, err := io.ReadAll(resp.Body)
		if err != nil {
			return fmt.Errorf("unexpected status code: %d. failed reading body: %w", resp.StatusCode, err)
		}
		return fmt.Errorf("unexpected status code: %d. body: %s", resp.StatusCode, string(bytes))
	}

	fmt.Println("uploaded")
	bytes, _ := io.ReadAll(resp.Body)
	fmt.Println(resp.StatusCode, string(bytes))
	fmt.Println("printed body")

	return nil
}
