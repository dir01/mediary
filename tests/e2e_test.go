package tests

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/dir01/mediary/downloader/torrent"
	http2 "github.com/dir01/mediary/http"
	"github.com/dir01/mediary/media_processor"
	"github.com/dir01/mediary/service"
	"github.com/dir01/mediary/service/jobs_queue"
	"github.com/dir01/mediary/storage"
	"github.com/go-redis/redis"
	"go.uber.org/zap"
)

var logger, _ = zap.NewDevelopment()

const magnetURL = "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65"

func TestApplication(t *testing.T) {
	downloader, err := torrent.NewTorrentDownloader(os.TempDir(), logger)
	if err != nil {
		t.Fatalf("error creating torrent downloader: %v", err)
	}

	redisURL, err := getRedisURL(context.Background())
	if err != nil {
		t.Fatalf("error getting redis url: %v", err)
	}
	opt, err := redis.ParseURL(redisURL)
	if err != nil {
		t.Fatalf("error parsing redis url: %v", err)
	}
	redisClient := redis.NewClient(opt)
	defer func() { _ = redisClient.Close() }()

	queue, err := jobs_queue.NewRedisJobsQueue(redisClient, 10, "mediary:")
	if err != nil {
		t.Fatalf("error initializing redis jobs queue: %v", err)
	}

	store := storage.NewStorageInMemory()
	mediaProcessor, err := media_processor.NewFFMpegMediaProcessor(logger)
	if err != nil {
		t.Fatalf("error creating media processor: %v", err)
	}
	svc := service.NewService(downloader, store, queue, mediaProcessor, logger)
	mux := http2.PrepareHTTPServerMux(svc)

	docs := newTestDocsHelper(
		t, mux, "../README.md",
		"<!-- start autogenerated samples -->",
		"<!-- stop autogenerated samples -->",
	)
	defer docs.Finish()

	t.Run("metadata with timeout", func(t *testing.T) {
		expectedResponse := `{"status": "accepted"}`
		docs.InsertText(`### '''/metadata''' - Timeouts

By default, the endpoint will timeout pretty quickly, 
probably sooner than it takes to fetch metadata of a torrent, for example.

In such cases, the endpoint will return a '''202 Accepted''' status code and a message '''%s'''

Feel free to repeat your request later: metadata is still being fetched in background.
`, expectedResponse)

		docs.PerformRequestForDocs("GET",
			`/metadata?url=`+magnetURL,
			nil,
			http.StatusAccepted,
			expectedResponse,
		)
	})

	t.Run("metadata with long-polling", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		docs.InsertText(`### '''/metadata/long-polling'''

In case you'd rather wait for the metadata to be fetched, you can use the long-polling endpoint.

It will not return a response until the metadata is fetched.

There is still a timeout on the request, but it's pretty long (5 minutes).`)

		docs.PerformRequestForDocs("GET",
			`/metadata/long-polling?url=`+magnetURL,
			nil,
			http.StatusOK,
			expectedResponse,
		)
	})

	t.Run("cached metadata", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		docs.InsertText(`### '''/metadata''' - Cached

It goes without saying, that once the metadata is fetched, it is cached.

So all consecutive requests for the same URL will return the same metadata, and immediately.`)

		docs.PerformRequestForDocs(
			"GET",
			`/metadata?url=`+magnetURL,
			nil,
			http.StatusOK,
			expectedResponse,
		)
	})

	t.Run("job creation", func(t *testing.T) {
		docs.InsertText(`### '''/jobs''' 

POST to '''/jobs''' will schedule for background execution a process of downloading, converting/processing and uploading the media.
Only required parameters are '''url''' and '''type'''. '''type''' signifies the type of operation to be performed. 
Each operation can require some additional parameters, passed as '''params'''`)

		docs.PerformRequestForDocs(
			"POST",
			"/jobs",
			strings.NewReader(fmt.Sprintf(`{
	"url": "%s",
	"type": "concatenate",
	"params": {
		"filepaths": [
			"01.-Part 1 - Acknowledgement.flac",
			"02.-Part 2 - Resolution.flac"
		],
		"audioCodec": "mp3"
	}
}`, magnetURL)),
			http.StatusAccepted,
			`{"status": "accepted"}`)
	})

}

func newTestDocsHelper(t *testing.T, mux *http.ServeMux, readmeLocation, blockStartMarker, blockEndMarker string) *testHelper {
	return &testHelper{t: t, mux: mux, readmeLocation: readmeLocation, blockStartMarker: blockStartMarker, blockEndMarker: blockEndMarker}
}

type testHelper struct {
	mux              *http.ServeMux
	t                *testing.T
	readmeLocation   string
	blockStartMarker string
	blockEndMarker   string
	stringBits       []string
}

func (h *testHelper) InsertText(text string, args ...interface{}) {
	h.stringBits = append(h.stringBits, fmt.Sprintf(text, args...))
}

func (h *testHelper) PerformRequestForDocs(method, url string, body io.Reader, expectedStatusCode int, expectedResponse string) *httptest.ResponseRecorder {
	resp := h.PerformRequest(method, url, body, expectedStatusCode, expectedResponse)

	var reqString string
	if body != nil {
		reqBodyBytes, err := ioutil.ReadAll(body)
		if err != nil {
			h.t.Fatalf("error reading request body: %v", err)
		}
		reqString = string(reqBodyBytes)
	}

	h.stringBits = append(h.stringBits, h.formatCall(method, url, reqString, resp.Body.String()))

	return resp
}

func (h *testHelper) PerformRequest(method string, url string, body io.Reader, expectedStatusCode int, expectedResponse string) *httptest.ResponseRecorder {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		h.t.Fatalf("error creating request: %v", err)
	}
	rr := httptest.NewRecorder()
	h.mux.ServeHTTP(rr, req)

	if status := rr.Code; status != expectedStatusCode {
		h.t.Errorf("handler returned wrong status code: got %v want %v\n%s", status, expectedStatusCode, rr.Body.String())
	}

	if rr.Body.String() != expectedResponse {
		fmt.Println(rr.Body.String())
		h.t.Errorf("handler returned unexpected body: got %v want %v",
			rr.Body.String(), expectedResponse)
	}

	return rr
}

func (h *testHelper) Finish() {
	readmeBytes, err := ioutil.ReadFile(h.readmeLocation)
	if err != nil {
		h.t.Fatalf("error reading file: %v", err)
	}

	textToInsert := strings.Join(h.stringBits, "\n")
	textToInsert = strings.ReplaceAll(textToInsert, "'''", "`")
	readmeString := h.insertBetweenBlockMarkers(string(readmeBytes), textToInsert)

	err = ioutil.WriteFile(h.readmeLocation, []byte(readmeString), 0644)
	if err != nil {
		h.t.Fatalf("error writing file: %v", err)
	}
}

func (h *testHelper) formatCall(method, url, body, respString string) string {
	callParts := []string{
		fmt.Sprintf("```\n$ curl -X %s '%s'", method, url),
	}
	if body != "" {
		callParts = append(callParts, fmt.Sprintf("--data-raw='%s'", body))
	}
	callParts = append(callParts, "\n", respString, "\n```\n\n")
	return strings.Join(callParts, "")
}

func (h *testHelper) insertBetweenBlockMarkers(s, toInsert string) string {
	beforeMarker := s[:strings.Index(s, h.blockStartMarker)]
	afterMarker := s[strings.Index(s, h.blockEndMarker)+len(h.blockEndMarker):]
	s = beforeMarker + h.blockStartMarker + "\n" + toInsert + h.blockEndMarker + afterMarker
	return s
}
