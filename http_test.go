package mediary_test

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/dir01/mediary"
)

func TestMetadataHandler(t *testing.T) {
	downloader, err := mediary.NewTorrentDownloader()
	if err != nil {
		t.Fatalf("error creating torrent downloader: %v", err)
	}
	service := mediary.NewService([]mediary.Downloader{downloader}, mediary.NewStorageInMemory())
	mux := mediary.PrepareHTTPServerMux(service)

	h := newTestHelper(t, mux, "README.md", "<!-- start autogenerated samples -->", "<!-- stop autogenerated samples -->")
	defer h.Finish()

	t.Run("metadata with timeout", func(t *testing.T) {
		expectedResponse := `{"foo": "bar"}`
		h.InsertText(`### /metadata - Timeouts

By default, the endpoint will timeout pretty quickly, 
probably sooner than it takes to fetch metadata of a torrent, for example.

In such cases, the endpoint will return a 202 Accepted status code and a message "%s"

Feel free to repeat your request later: metadata is still being fetched in background.
`, expectedResponse)

		h.PerformRequestForDocs("GET",
			`/metadata?url=magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65`,
			nil,
			http.StatusAccepted,
			expectedResponse,
		)
	})

	t.Run("metadata with long-polling", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		h.InsertText(`### /metadata/long-polling

In case you'd rather wait for the metadata to be fetched, you can use the long-polling endpoint.

It will not return a response until the metadata is fetched.

There is still a timeout on the request, but it's pretty long (5 minutes).`)

		h.PerformRequestForDocs("GET",
			`/metadata/long-polling?url=magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65`,
			nil,
			http.StatusOK,
			expectedResponse,
		)
	})

	t.Run("cached metadata", func(t *testing.T) {
		expectedResponse := `{
  "url": "magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65",
  "name": "John Coltrane - A Love Supreme (1965) (Acoustic Sounds Series) (PBTHAL LP 24-96) [FLAC] vtwin88cube",
  "files": [
    {
      "path": "00.-John Coltrane - A Love Supreme.m3u",
      "length_bytes": 111
    },
    {
      "path": "01.-Part 1 - Acknowledgement.flac",
      "length_bytes": 170093783
    },
    {
      "path": "02.-Part 2 - Resolution.flac",
      "length_bytes": 165357192
    },
    {
      "path": "03.-Part 3 - Pursuance \u0026 Part 4 - Psalm.flac",
      "length_bytes": 386514548
    },
    {
      "path": "DR13.txt",
      "length_bytes": 979
    },
    {
      "path": "folder.jpg",
      "length_bytes": 187670
    },
    {
      "path": "lineage.txt",
      "length_bytes": 556
    }
  ]
}`

		h.InsertText(`### /metadata - Cached

It goes without saying, that once the metadata is fetched, it is cached.

So all consequitive requests for the same URL will return the same metadata, and immediately.`)

		h.PerformRequestForDocs("GET",
			`/metadata?url=magnet:?xt=urn:btih:1EAA77FA58C40D5499914AE740EC7F906EF10D65`,
			nil,
			http.StatusOK,
			expectedResponse,
		)
	})

}

func newTestHelper(t *testing.T, mux *http.ServeMux, readmeLocation, blockStartMarker, blockEndMarker string) *testHelper {
	return &testHelper{t: t, mux: mux, readmeLocation: readmeLocation, blockStartMarker: blockStartMarker, blockEndMarker: blockEndMarker}
}

type testHelper struct {
	mux              *http.ServeMux
	t                *testing.T
	readmeLocation   string
	blockStartMarker string
	blockEndMarker   string
	stringBits       []string
}

func (h *testHelper) InsertText(text string, args ...interface{}) {
	h.stringBits = append(h.stringBits, fmt.Sprintf(text, args...))
}

func (h *testHelper) PerformRequestForDocs(method, url string, body io.Reader, expectedStatusCode int, expectedResponse string) *httptest.ResponseRecorder {
	resp := h.PerformRequest(method, url, body, expectedStatusCode, expectedResponse)

	var reqString string
	if body != nil {
		reqBodyBytes, err := ioutil.ReadAll(body)
		if err != nil {
			h.t.Fatalf("error reading request body: %v", err)
		}
		reqString = string(reqBodyBytes)
	}

	h.stringBits = append(h.stringBits, h.formatCall(method, url, reqString, resp.Body.String()))

	return resp
}

func (h *testHelper) PerformRequest(method string, url string, body io.Reader, expectedStatusCode int, expectedResponse string) *httptest.ResponseRecorder {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		h.t.Fatalf("error creating request: %v", err)
	}
	rr := httptest.NewRecorder()
	h.mux.ServeHTTP(rr, req)

	if status := rr.Code; status != expectedStatusCode {
		h.t.Errorf("handler returned wrong status code: got %v want %v\n%s", status, http.StatusOK, rr.Body.String())
	}

	if rr.Body.String() != expectedResponse {
		fmt.Println(rr.Body.String())
		h.t.Errorf("handler returned unexpected body: got %v want %v",
			rr.Body.String(), expectedResponse)
	}

	return rr
}

func (h *testHelper) Finish() {
	readmeBytes, err := ioutil.ReadFile(h.readmeLocation)
	if err != nil {
		h.t.Fatalf("error reading file: %v", err)
	}

	readmeString := h.insertBetweenBlockMarkers(string(readmeBytes), strings.Join(h.stringBits, "\n"))

	err = ioutil.WriteFile(h.readmeLocation, []byte(readmeString), 0644)
	if err != nil {
		h.t.Fatalf("error writing file: %v", err)
	}
}

func (h *testHelper) formatCall(method, url, body, respString string) string {
	callParts := []string{
		fmt.Sprintf("```\n$ curl -X %s '%s'", method, url),
	}
	if body != "" {
		callParts = append(callParts, fmt.Sprintf("--data-raw='%s'", body))
	}
	callParts = append(callParts, "\n", respString, "\n```\n\n")
	return strings.Join(callParts, "")
}

func (h *testHelper) insertBetweenBlockMarkers(s, toInsert string) string {
	beforeMarker := s[:strings.Index(s, h.blockStartMarker)]
	afterMarker := s[strings.Index(s, h.blockEndMarker)+len(h.blockEndMarker):]
	s = beforeMarker + h.blockStartMarker + "\n" + toInsert + h.blockEndMarker + afterMarker
	return s
}
